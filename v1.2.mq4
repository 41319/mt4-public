//+------------------------------------------------------------------+
//|                                                      HKIndex.mq4 |
//|                        Generated by MetaEditor                   |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Your Name"
#property link      "https://www.yourwebsite.com"
#property version   "1.42"
#property strict

// Enumeration for trading modes
enum ENUM_TRADING_MODE
{
   MODE_LONG,    // Long positions only
   MODE_SHORT,   // Short positions only
   MODE_MIXED    // Both long and short positions
};

// Input parameters
input double LotSize = 0.01;
input int TrailingStopPoints = 30 * 10;      // Only activates in profit
input int BreakevenTriggerPoints = 50 * 10;  // Profit level to activate stop
input int MaxOrders = 10;
input double PriceLevelAdjustment = 25 * 10; // In points
input int OrderExpirationHours = 24;         // Pending order expiration
input double GapThresholdPoints = 26 * 10;   // Points above/below level to trigger recalculation
input ENUM_TRADING_MODE TradingMode = MODE_MIXED; // Trading mode

// Working variables
int workingTrailingStopPoints;
int workingBreakevenTriggerPoints;
double workingPriceLevelAdjustment;
double workingGapThresholdPoints;

// Global variables
double longPriceLevels[];
double shortPriceLevels[];
datetime lastCheckDate = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // Apply multiplier for US30 symbol to working variables
   double multiplier = (Symbol() == "US30") ? 10.0 : 1.0;
   
   workingTrailingStopPoints = (int)(TrailingStopPoints * multiplier);
   workingBreakevenTriggerPoints = (int)(BreakevenTriggerPoints * multiplier);
   workingPriceLevelAdjustment = PriceLevelAdjustment * multiplier;
   workingGapThresholdPoints = GapThresholdPoints * multiplier;
   
   if(multiplier == 10.0)
   {
      Print("US30 detected. Applying 10x multiplier to working parameters:");
      Print("WorkingTrailingStopPoints=", workingTrailingStopPoints);
      Print("WorkingBreakevenTriggerPoints=", workingBreakevenTriggerPoints);
      Print("WorkingPriceLevelAdjustment=", workingPriceLevelAdjustment);
      Print("WorkingGapThresholdPoints=", workingGapThresholdPoints);
   }
   
   UpdatePriceLevels();
   UpdateChartDisplay();
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   DeleteChartDisplay();
   DeleteAllArrows();
   Print("HKIndex EA deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   bool isNewDay = TimeDay(TimeCurrent()) != TimeDay(lastCheckDate);
   
   if(isNewDay)
   {
      Print("New day detected.");
      lastCheckDate = TimeCurrent();
      UpdateChartDisplay();
   }
   
   // Check if price has moved beyond our levels + gap threshold
   if(CheckPriceGap() || isNewDay)
   {
      UpdatePriceLevels();
      CloseAllPendingOrders();
      UpdateChartDisplay();
   }
   
   ManageOrders();
   CheckForTrailingStop();
}

//+------------------------------------------------------------------+
//| Count open and pending orders for the current symbol             |
//+------------------------------------------------------------------+
int CountOrders()
{
   int count = 0;
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) && OrderSymbol() == Symbol())
      {
         count++;
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Create order comment with parameters                             |
//+------------------------------------------------------------------+
string CreateOrderComment()
{
   string comment = StringFormat("HKIndex|Lots=%.2f|Trail=%d|BE=%d|Max=%d|Adj=%.1f|Exp=%dh|Gap=%.1f|Mode=%d",
      LotSize,
      workingTrailingStopPoints,
      workingBreakevenTriggerPoints,
      MaxOrders,
      workingPriceLevelAdjustment,
      OrderExpirationHours,
      workingGapThresholdPoints,
      TradingMode);
      
   return comment;
}

//+------------------------------------------------------------------+
//| Check if current price exceeds levels by gap threshold           |
//+------------------------------------------------------------------+
bool CheckPriceGap()
{
   static datetime lastGapCheckTime = 0;
   if(TimeCurrent() - lastGapCheckTime < 3600) return false; // Only check once per hour
   lastGapCheckTime = TimeCurrent();
   
   double currentPrice = MarketInfo(Symbol(), MODE_BID);
   double gapThreshold = workingGapThresholdPoints * MarketInfo(Symbol(), MODE_POINT);
   
   if(TradingMode == MODE_LONG || TradingMode == MODE_MIXED)
   {
      if(ArraySize(longPriceLevels) > 0)
      {
         double highestLevel = longPriceLevels[ArrayMaximum(longPriceLevels)];
         if(currentPrice > (highestLevel + gapThreshold))
         {
            Print("Price gap detected (longs). Current: ", currentPrice, 
                  " > Highest Level: ", highestLevel, 
                  " + Gap: ", gapThreshold, ". Recalculating levels.");
            return true;
         }
      }
   }
   
   if(TradingMode == MODE_SHORT || TradingMode == MODE_MIXED)
   {
      if(ArraySize(shortPriceLevels) > 0)
      {
         double lowestLevel = shortPriceLevels[ArrayMinimum(shortPriceLevels)];
         if(currentPrice < (lowestLevel - gapThreshold))
         {
            Print("Price gap detected (shorts). Current: ", currentPrice, 
                  " < Lowest Level: ", lowestLevel, 
                  " - Gap: ", gapThreshold, ". Recalculating levels.");
            return true;
         }
      }
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Check if price level is valid considering existing orders        |
//+------------------------------------------------------------------+
bool IsValidPriceLevel(double price, bool isLong)
{
   double minDistance = workingPriceLevelAdjustment * MarketInfo(Symbol(), MODE_POINT);
   
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) && OrderSymbol() == Symbol())
      {
         double orderPrice = OrderOpenPrice();
         double distance = MathAbs(price - orderPrice);
         
         // If distance is less than required, level is invalid
         if(distance < minDistance)
         {
            Print("Invalid level: ", price, " too close to existing order at ", orderPrice);
            return false;
         }
      }
   }
   
   // Additional validation for long/short levels
   if(isLong)
   {
      if(price >= MarketInfo(Symbol(), MODE_ASK))
      {
         Print("Invalid long level: ", price, " above current ask price");
         return false;
      }
   }
   else
   {
      if(price <= MarketInfo(Symbol(), MODE_BID))
      {
         Print("Invalid short level: ", price, " below current bid price");
         return false;
      }
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Place a pending order (BuyLimit or SellLimit)                    |
//+------------------------------------------------------------------+
bool PlaceOrder(int index, bool isLong)
{
   if(isLong && (index < 0 || index >= ArraySize(longPriceLevels))) return false;
   if(!isLong && (index < 0 || index >= ArraySize(shortPriceLevels))) return false;

   double triggerPrice = isLong ? longPriceLevels[index] : shortPriceLevels[index];
   if(triggerPrice == 0.0) return false;
   
   // Validate the price level before placing order
   if(!IsValidPriceLevel(triggerPrice, isLong))
      return false;
   
   double point = MarketInfo(Symbol(), MODE_POINT);
   int digits = (int)MarketInfo(Symbol(), MODE_DIGITS);
   datetime expiryTime = TimeCurrent() + OrderExpirationHours * 3600;
   int orderType = isLong ? OP_BUYLIMIT : OP_SELLLIMIT;
   color orderColor = isLong ? clrGreen : clrRed;
   string comment = CreateOrderComment();

   Print("Attempting ", (isLong ? "BUYLIMIT" : "SELLLIMIT"), " @ ", triggerPrice);
   int ticket = OrderSend(Symbol(), orderType, LotSize, triggerPrice, 3, 0, 0, comment, 0, expiryTime, orderColor);

   if(ticket < 0)
   {
      Print("OrderSend failed. Error: ", GetLastError());
      return false;
   }
   else
   {
      Print("Order placed. Ticket #", ticket);
      UpdateChartDisplay();
      return true;
   }
}

//+------------------------------------------------------------------+
//| Manage all orders - create new ones if needed                    |
//+------------------------------------------------------------------+
void ManageOrders()
{
   int count = CountOrders();
   
   if(TradingMode == MODE_LONG || TradingMode == MODE_MIXED)
   {
      for(int i = 0; i < ArraySize(longPriceLevels); i++)
      {
         if(count >= MaxOrders) break;

         bool orderExists = false;
         for(int j = 0; j < OrdersTotal(); j++)
         {
            if(OrderSelect(j, SELECT_BY_POS, MODE_TRADES) && OrderSymbol() == Symbol())
            {
               if(OrderType() == OP_BUYLIMIT &&
                  MathAbs(OrderOpenPrice() - longPriceLevels[i]) < MarketInfo(Symbol(), MODE_POINT))
               {
                  orderExists = true;
                  break;
               }
            }
         }

         if(!orderExists && PlaceOrder(i, true))
            count++;
      }
   }
   
   if(TradingMode == MODE_SHORT || TradingMode == MODE_MIXED)
   {
      for(int i = 0; i < ArraySize(shortPriceLevels); i++)
      {
         if(count >= MaxOrders) break;

         bool orderExists = false;
         for(int j = 0; j < OrdersTotal(); j++)
         {
            if(OrderSelect(j, SELECT_BY_POS, MODE_TRADES) && OrderSymbol() == Symbol())
            {
               if(OrderType() == OP_SELLLIMIT &&
                  MathAbs(OrderOpenPrice() - shortPriceLevels[i]) < MarketInfo(Symbol(), MODE_POINT))
               {
                  orderExists = true;
                  break;
               }
            }
         }

         if(!orderExists && PlaceOrder(i, false))
            count++;
      }
   }
}

//+------------------------------------------------------------------+
//| Update price levels based on current market price                |
//+------------------------------------------------------------------+
void UpdatePriceLevels()
{
    double bidPrice = MarketInfo(Symbol(), MODE_BID);
    double askPrice = MarketInfo(Symbol(), MODE_ASK);
    int maxOrdersPerSide = (int)MathFloor(MaxOrders / (TradingMode == MODE_MIXED ? 2.0 : 1.0));
    int digits = (int)MarketInfo(Symbol(), MODE_DIGITS);
    double minDistanceFromPrice = workingPriceLevelAdjustment * MarketInfo(Symbol(), MODE_POINT);

    // Clear existing levels
    ArrayResize(longPriceLevels, 0);
    ArrayResize(shortPriceLevels, 0);

    // --- Generate Long Levels ---
    if(TradingMode == MODE_LONG || TradingMode == MODE_MIXED)
    {
        for(int i = 0; i < maxOrdersPerSide; i++)
        {
            double potentialLevel = NormalizeDouble(
               bidPrice - (workingPriceLevelAdjustment * (i + 1) * MarketInfo(Symbol(), MODE_POINT)),
               digits);

            if((bidPrice - potentialLevel) >= minDistanceFromPrice)
            {
                int size = ArraySize(longPriceLevels);
                ArrayResize(longPriceLevels, size + 1);
                longPriceLevels[size] = potentialLevel;
            }
        }
    }

    // --- Generate Short Levels ---
    if(TradingMode == MODE_SHORT || TradingMode == MODE_MIXED)
    {
        for(int i = 0; i < maxOrdersPerSide; i++)
        {
            double potentialLevel = NormalizeDouble(
               askPrice + (workingPriceLevelAdjustment * (i + 1) * MarketInfo(Symbol(), MODE_POINT)),
               digits);

            if((potentialLevel - askPrice) >= minDistanceFromPrice)
            {
                int size = ArraySize(shortPriceLevels);
                ArrayResize(shortPriceLevels, size + 1);
                shortPriceLevels[size] = potentialLevel;
            }
        }
    }

    // Debug output
    Print("Generated ", ArraySize(longPriceLevels), " long and ", 
          ArraySize(shortPriceLevels), " short price levels.");
}

//+------------------------------------------------------------------+
//| Close all pending orders                                         |
//+------------------------------------------------------------------+
void CloseAllPendingOrders()
{
   for(int i = OrdersTotal()-1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) && OrderSymbol() == Symbol())
      {
         if(OrderType() == OP_BUYLIMIT || OrderType() == OP_SELLLIMIT)
         {
            bool result = OrderDelete(OrderTicket());
            if(!result)
               Print("Failed to delete order. Error: ", GetLastError());
            else
               UpdateChartDisplay();
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Smart Trailing Stop - Only protects profits                      |
//+------------------------------------------------------------------+
void CheckForTrailingStop()
{
   double point = MarketInfo(Symbol(), MODE_POINT);
   
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) && OrderSymbol() == Symbol())
      {
         bool isModified = false;
         if(OrderType() == OP_BUY && (TradingMode == MODE_LONG || TradingMode == MODE_MIXED))
         {
            double currentProfit = MarketInfo(Symbol(), MODE_BID) - OrderOpenPrice();
            double currentStop = OrderStopLoss();
            
            if(currentProfit >= workingBreakevenTriggerPoints * point)
            {
               double newStop = OrderOpenPrice() + (currentProfit - workingTrailingStopPoints * point);
               
               if(currentStop == 0 || newStop > currentStop)
               {
                  if(!OrderModify(OrderTicket(), OrderOpenPrice(), newStop, 0, 0, clrNONE))
                     Print("Failed to modify stop. Error: ", GetLastError());
                  else
                     isModified = true;
               }
            }
         }
         else if(OrderType() == OP_SELL && (TradingMode == MODE_SHORT || TradingMode == MODE_MIXED))
         {
            double currentProfit = OrderOpenPrice() - MarketInfo(Symbol(), MODE_ASK);
            double currentStop = OrderStopLoss();
            
            if(currentProfit >= workingBreakevenTriggerPoints * point)
            {
               double newStop = OrderOpenPrice() - (currentProfit - workingTrailingStopPoints * point);
               
               if(currentStop == 0 || newStop < currentStop)
               {
                  if(!OrderModify(OrderTicket(), OrderOpenPrice(), newStop, 0, 0, clrNONE))
                     Print("Failed to modify stop. Error: ", GetLastError());
                  else
                     isModified = true;
               }
            }
         }
         if(isModified) UpdateChartDisplay();
      }
   }
}

//+------------------------------------------------------------------+
//| Update display with input variables and price levels             |
//+------------------------------------------------------------------+
void UpdateChartDisplay()
{
    DeleteChartDisplay();

    string modeStr = "Mixed";
    if(TradingMode == MODE_LONG) modeStr = "Long Only";
    if(TradingMode == MODE_SHORT) modeStr = "Short Only";
    
    int openOrders = 0, pendingOrders = 0;
    for(int i = 0; i < OrdersTotal(); i++)
    {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) && OrderSymbol() == Symbol())
        {
            if(OrderType() == OP_BUY || OrderType() == OP_SELL) openOrders++;
            else if(OrderType() == OP_BUYLIMIT || OrderType() == OP_SELLLIMIT) pendingOrders++;
        }
    }

    color bgColor = (color)ChartGetInteger(0, CHART_COLOR_BACKGROUND);
    color textColor = (bgColor == clrBlack || bgColor == clrNavy) ? clrWhite : clrBlack;
    color longColor = clrGreen;
    color shortColor = clrRed;

    // Get the point value for the current symbol
    double pointValue = MarketInfo(Symbol(), MODE_POINT);
    int digits = (int)MarketInfo(Symbol(), MODE_DIGITS);
    
    // Display settings
    int yPos = 180;
    CreateOrUpdateText("Display_Header", "--- HKIndex Settings ---", 5, yPos, textColor, true); yPos -= 15;
    CreateOrUpdateText("Display_PointValue", "Point Value: " + DoubleToString(pointValue, digits), 5, yPos, textColor, true); yPos -= 15;
    CreateOrUpdateText("Display_OpenOrders", "Open Orders: " + IntegerToString(openOrders), 5, yPos, textColor, true); yPos -= 15;
    CreateOrUpdateText("Display_PendingOrders", "Pending Orders: " + IntegerToString(pendingOrders), 5, yPos, textColor, true); yPos -= 15;
    CreateOrUpdateText("Display_LotSize", "Lot Size: " + DoubleToString(LotSize, 2), 5, yPos, textColor, true); yPos -= 15;
    CreateOrUpdateText("Display_Trail", "Trailing Stop: " + IntegerToString(TrailingStopPoints) + " pts", 5, yPos, textColor, true); yPos -= 15;
    CreateOrUpdateText("Display_BE", "Breakeven Trigger: " + IntegerToString(BreakevenTriggerPoints) + " pts", 5, yPos, textColor, true); yPos -= 15;
    CreateOrUpdateText("Display_MaxOrders", "Max Orders: " + IntegerToString(MaxOrders), 5, yPos, textColor, true); yPos -= 15;
    CreateOrUpdateText("Display_Adjust", "Price Adjustment: " + DoubleToString(PriceLevelAdjustment, 1) + " pts", 5, yPos, textColor, true); yPos -= 15;
    CreateOrUpdateText("Display_Expiry", "Order Expiry: " + IntegerToString(OrderExpirationHours) + " hours", 5, yPos, textColor, true); yPos -= 15;
    CreateOrUpdateText("Display_Gap", "Gap Threshold: " + DoubleToString(GapThresholdPoints, 1) + " pts", 5, yPos, textColor, true); yPos -= 15;
    CreateOrUpdateText("Display_Mode", "Trading Mode: " + modeStr, 5, yPos, textColor, true); yPos -= 30;

    // Display long price levels
    if(TradingMode == MODE_LONG || TradingMode == MODE_MIXED)
    {
        CreateOrUpdateText("Display_LongHeader", "--- LONG Levels ---", 5, yPos, longColor, true); yPos -= 15;
        
        for(int i = 0; i < ArraySize(longPriceLevels); i++)
        {
            string levelText = StringFormat("L%d: %s", i+1, DoubleToString(longPriceLevels[i], digits));
            CreateOrUpdateText("Display_LongLevel"+IntegerToString(i), levelText, 5, yPos, longColor, true);
            
            // Create horizontal line for this price level
            string lineName = "LongLevelLine_"+IntegerToString(i);
            CreatePriceLevelLine(lineName, longPriceLevels[i], longColor, levelText);
            
            yPos -= 15;
            if(yPos < 15) break; // Prevent going off the bottom of the chart
        }
        
        yPos -= 15; // Extra space before shorts
    }

    // Display short price levels
    if(TradingMode == MODE_SHORT || TradingMode == MODE_MIXED)
    {
        CreateOrUpdateText("Display_ShortHeader", "--- SHORT Levels ---", 5, yPos, shortColor, true); yPos -= 15;
        
        for(int i = 0; i < ArraySize(shortPriceLevels); i++)
        {
            string levelText = StringFormat("S%d: %s", i+1, DoubleToString(shortPriceLevels[i], digits));
            CreateOrUpdateText("Display_ShortLevel"+IntegerToString(i), levelText, 5, yPos, shortColor, true);
            
            // Create horizontal line for this price level
            string lineName = "ShortLevelLine_"+IntegerToString(i);
            CreatePriceLevelLine(lineName, shortPriceLevels[i], shortColor, levelText);
            
            yPos -= 15;
            if(yPos < 15) break; // Prevent going off the bottom of the chart
        }
    }
    
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| Create a horizontal line for a price level                       |
//+------------------------------------------------------------------+
void CreatePriceLevelLine(string name, double price, color clr, string description)
{
    if(ObjectFind(0, name) < 0)
    {
        ObjectCreate(0, name, OBJ_HLINE, 0, 0, price);
        ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
        ObjectSetInteger(0, name, OBJPROP_STYLE, STYLE_DASHDOT);
        ObjectSetInteger(0, name, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, name, OBJPROP_BACK, true);
        ObjectSetString(0, name, OBJPROP_TEXT, description);
    }
    else
    {
        ObjectMove(0, name, 0, 0, price);
    }
}

//+------------------------------------------------------------------+
//| Helper to create or update a text object                         |
//+------------------------------------------------------------------+
void CreateOrUpdateText(string name, string text, int x, int y, color clr, bool backdrop)
{
    if(ObjectFind(0, name) != 0)
    {
        ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
        ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
        ObjectSetInteger(0, name, OBJPROP_CORNER, CORNER_RIGHT_LOWER);
        ObjectSetInteger(0, name, OBJPROP_ANCHOR, ANCHOR_RIGHT);
    }
    ObjectSetString(0, name, OBJPROP_TEXT, text);
    ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
    ObjectSetInteger(0, name, OBJPROP_BACK, backdrop);
}

//+------------------------------------------------------------------+
//| Delete all display objects from chart                            |
//+------------------------------------------------------------------+
void DeleteChartDisplay()
{
    string prefix = "Display_";
    string linePrefix = "LevelLine_";
    
    // Delete text objects
    for(int i = ObjectsTotal(0, -1, OBJ_LABEL) - 1; i >= 0; i--)
    {
        string name = ObjectName(0, i, -1, OBJ_LABEL);
        if(StringFind(name, prefix, 0) == 0)
        {
            ObjectDelete(0, name);
        }
    }
    
    // Delete horizontal lines
    for(int i = ObjectsTotal(0, -1, OBJ_HLINE) - 1; i >= 0; i--)
    {
        string name = ObjectName(0, i, -1, OBJ_HLINE);
        if(StringFind(name, "LongLevelLine_", 0) == 0 || StringFind(name, "ShortLevelLine_", 0) == 0)
        {
            ObjectDelete(0, name);
        }
    }
}

//+------------------------------------------------------------------+
//| Delete all arrow objects from chart                              |
//+------------------------------------------------------------------+
void DeleteAllArrows()
{
    int total = ObjectsTotal();
    for(int i = total-1; i >= 0; i--)
    {
        string name = ObjectName(i);
        if(ObjectType(name) == OBJ_ARROW)
        {
            ObjectDelete(name);
        }
    }
}

//+------------------------------------------------------------------+
//| Helper function to convert order type to string                  |
//+------------------------------------------------------------------+
string OrderTypeToString(int type)
{
   switch(type)
   {
      case OP_BUY: return "BUY";
      case OP_SELL: return "SELL";
      case OP_BUYLIMIT: return "BUYLIMIT";
      case OP_SELLLIMIT: return "SELLLIMIT";
      case OP_BUYSTOP: return "BUYSTOP";
      case OP_SELLSTOP: return "SELLSTOP";
      default: return "UNKNOWN";
   }
}