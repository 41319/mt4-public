//+------------------------------------------------------------------+
//|                                                      HKIndex.mq4 |
//|                        Generated by MetaEditor                   |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Your Name"
#property link      "https://www.yourwebsite.com"
#property version   "1.30"
#property strict

// Input parameters
input double LotSize = 0.01;
input int TrailingStopPoints = 30 * 10;      // Only activates in profit
input int BreakevenTriggerPoints = 50 * 10;  // Profit level to activate stop
input int MaxOrders = 10;
input int MagicNumber = 12345;
input double PriceLevelAdjustment = 25 * 10;
input bool UsePercentage = false;
input int OrderExpirationHours = 24;         // Pending order expiration
input double GapThresholdPoints = 26 * 10;   // Points above/below level to trigger recalculation
input ENUM_TRADING_MODE TradingMode = MODE_MIXED; // Trading mode: MODE_LONG, MODE_SHORT, MODE_MIXED

// Enumeration for trading modes
enum ENUM_TRADING_MODE
{
   MODE_LONG,    // Long positions only
   MODE_SHORT,   // Short positions only
   MODE_MIXED    // Both long and short positions
};

// Global variables
double longPriceLevels[];
double shortPriceLevels[];
datetime lastCheckDate = 0;
double monthlyVolume = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   monthlyVolume = CalculateClosedVolumeThisMonth();
   UpdatePriceLevels();
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("HKIndex EA deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   bool isNewDay = TimeDay(TimeCurrent()) != TimeDay(lastCheckDate);
   
   if(isNewDay)
   {
      monthlyVolume = CalculateClosedVolumeThisMonth();
      Print("New day detected. Monthly volume so far: ", monthlyVolume);
      lastCheckDate = TimeCurrent();
   }
   
   // Check if price has moved beyond our levels + gap threshold
   if(CheckPriceGap() || isNewDay)
   {
      UpdatePriceLevels();
      CloseAllPendingOrders();
   }
   
   ManageOrders();
   CheckForTrailingStop();
   DeleteAllArrows();
}

//+------------------------------------------------------------------+
//| Check if current price exceeds levels by gap threshold           |
//+------------------------------------------------------------------+
bool CheckPriceGap()
{
   double currentPrice = MarketInfo(Symbol(), MODE_BID);
   double gapThreshold = GapThresholdPoints * MarketInfo(Symbol(), MODE_POINT);
   
   if(TradingMode == MODE_LONG || TradingMode == MODE_MIXED)
   {
      if(ArraySize(longPriceLevels) > 0)
      {
         double highestLevel = longPriceLevels[ArrayMaximum(longPriceLevels)];
         if(currentPrice > (highestLevel + gapThreshold))
         {
            Print("Price gap detected (", currentPrice, " > ", highestLevel, " + ", gapThreshold, "). Recalculating levels.");
            return true;
         }
      }
   }
   
   if(TradingMode == MODE_SHORT || TradingMode == MODE_MIXED)
   {
      if(ArraySize(shortPriceLevels) > 0)
      {
         double lowestLevel = shortPriceLevels[ArrayMinimum(shortPriceLevels)];
         if(currentPrice < (lowestLevel - gapThreshold))
         {
            Print("Price gap detected (", currentPrice, " < ", lowestLevel, " - ", gapThreshold, "). Recalculating levels.");
            return true;
         }
      }
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Count existing orders with matching symbol and magic             |
//+------------------------------------------------------------------+
int CountOrders()
{
   int count = 0;
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            count++;
         }
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Place a pending order (BuyLimit or SellLimit)                    |
//+------------------------------------------------------------------+
void PlaceOrder(int index, bool isLong)
{
   double point = MarketInfo(Symbol(), MODE_POINT);
   int digits = (int)MarketInfo(Symbol(), MODE_DIGITS);
   double triggerPrice = isLong ? longPriceLevels[index] : shortPriceLevels[index];
   datetime expiryTime = TimeCurrent() + OrderExpirationHours * 3600;
   int orderType = isLong ? OP_BUYLIMIT : OP_SELLLIMIT;
   color orderColor = isLong ? clrGreen : clrRed;

   // Safety checks
   if(isLong && triggerPrice >= MarketInfo(Symbol(), MODE_ASK))
   {
      Print("BuyLimit trigger price too high. Skipping. Trigger: ", triggerPrice, " >= Ask: ", MarketInfo(Symbol(), MODE_ASK));
      return;
   }
   
   if(!isLong && triggerPrice <= MarketInfo(Symbol(), MODE_BID))
   {
      Print("SellLimit trigger price too low. Skipping. Trigger: ", triggerPrice, " <= Bid: ", MarketInfo(Symbol(), MODE_BID));
      return;
   }

   Print("Attempting ", (isLong ? "BUYLIMIT" : "SELLLIMIT"), " @ ", triggerPrice);
   int ticket = OrderSend(Symbol(), orderType, LotSize, triggerPrice, 3, 0, 0, "HKIndex EA", MagicNumber, expiryTime, orderColor);

   if(ticket < 0)
      Print("OrderSend failed. Error: ", GetLastError());
   else
      Print("Order placed. Ticket #", ticket);
}

//+------------------------------------------------------------------+
//| Manage all orders - create new ones if needed                    |
//+------------------------------------------------------------------+
void ManageOrders()
{
   int count = CountOrders();
   int maxOrdersPerSide = (int)MathFloor(MaxOrders / (TradingMode == MODE_MIXED ? 2.0 : 1.0));
   
   // Handle long orders
   if(TradingMode == MODE_LONG || TradingMode == MODE_MIXED)
   {
      for(int i = 0; i < maxOrdersPerSide; i++)
      {
         bool orderExists = false;
         for(int j = 0; j < OrdersTotal(); j++)
         {
            if(OrderSelect(j, SELECT_BY_POS, MODE_TRADES))
            {
               if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && OrderType() == OP_BUYLIMIT &&
                  MathAbs(OrderOpenPrice() - longPriceLevels[i]) < MarketInfo(Symbol(), MODE_POINT))
               {
                  orderExists = true;
                  break;
               }
            }
         }

         if(!orderExists && count < MaxOrders)
         {
            PlaceOrder(i, true);
            count++;
         }
      }
   }
   
   // Handle short orders
   if(TradingMode == MODE_SHORT || TradingMode == MODE_MIXED)
   {
      for(int i = 0; i < maxOrdersPerSide; i++)
      {
         bool orderExists = false;
         for(int j = 0; j < OrdersTotal(); j++)
         {
            if(OrderSelect(j, SELECT_BY_POS, MODE_TRADES))
            {
               if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && OrderType() == OP_SELLLIMIT &&
                  MathAbs(OrderOpenPrice() - shortPriceLevels[i]) < MarketInfo(Symbol(), MODE_POINT))
               {
                  orderExists = true;
                  break;
               }
            }
         }

         if(!orderExists && count < MaxOrders)
         {
            PlaceOrder(i, false);
            count++;
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Update price levels based on current market price                |
//+------------------------------------------------------------------+
void UpdatePriceLevels()
{
   double currentPrice = MarketInfo(Symbol(), MODE_BID);
   int maxOrdersPerSide = (int)MathFloor(MaxOrders / (TradingMode == MODE_MIXED ? 2.0 : 1.0));
   
   // Update long levels
   if(TradingMode == MODE_LONG || TradingMode == MODE_MIXED)
   {
      ArrayResize(longPriceLevels, maxOrdersPerSide);
      for(int i = 0; i < maxOrdersPerSide; i++)
      {
         if(UsePercentage)
         {
            longPriceLevels[i] = currentPrice * (1 - (PriceLevelAdjustment / 100.0 * (i + 1)));
         }
         else
         {
            longPriceLevels[i] = NormalizeDouble(currentPrice - (PriceLevelAdjustment * (i + 1) * MarketInfo(Symbol(), MODE_POINT)), (int)MarketInfo(Symbol(), MODE_DIGITS));
         }
         Print("Long Price Level ", i+1, ": ", longPriceLevels[i]);
      }
   }
   
   // Update short levels
   if(TradingMode == MODE_SHORT || TradingMode == MODE_MIXED)
   {
      ArrayResize(shortPriceLevels, maxOrdersPerSide);
      for(int i = 0; i < maxOrdersPerSide; i++)
      {
         if(UsePercentage)
         {
            shortPriceLevels[i] = currentPrice * (1 + (PriceLevelAdjustment / 100.0 * (i + 1)));
         }
         else
         {
            shortPriceLevels[i] = NormalizeDouble(currentPrice + (PriceLevelAdjustment * (i + 1) * MarketInfo(Symbol(), MODE_POINT)), (int)MarketInfo(Symbol(), MODE_DIGITS));
         }
         Print("Short Price Level ", i+1, ": ", shortPriceLevels[i]);
      }
   }
}

//+------------------------------------------------------------------+
//| Close all pending orders                                         |
//+------------------------------------------------------------------+
void CloseAllPendingOrders()
{
   for(int i = OrdersTotal()-1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && 
            (OrderType() == OP_BUYLIMIT || OrderType() == OP_SELLLIMIT))
         {
            bool result = OrderDelete(OrderTicket());
            if(!result)
               Print("Failed to delete order. Error: ", GetLastError());
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate closed order volume for current month                  |
//+------------------------------------------------------------------+
double CalculateClosedVolumeThisMonth()
{
   double totalVolume = 0.0;
   datetime monthStart = iTime(NULL, PERIOD_MN1, 0);
   
   for(int i = OrdersHistoryTotal()-1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_HISTORY))
      {
         if(OrderCloseTime() >= monthStart && OrderMagicNumber() == MagicNumber)
         {
            totalVolume += OrderLots();
         }
      }
   }
   return totalVolume;
}

//+------------------------------------------------------------------+
//| Smart Trailing Stop - Only protects profits                      |
//+------------------------------------------------------------------+
void CheckForTrailingStop()
{
   double point = MarketInfo(Symbol(), MODE_POINT);
   
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            if(OrderType() == OP_BUY && (TradingMode == MODE_LONG || TradingMode == MODE_MIXED))
            {
               double currentProfit = MarketInfo(Symbol(), MODE_BID) - OrderOpenPrice();
               double currentStop = OrderStopLoss();
               
               if(currentProfit >= BreakevenTriggerPoints * point)
               {
                  double newStop = OrderOpenPrice() + (currentProfit - TrailingStopPoints * point);
                  
                  if(currentStop == 0 || newStop > currentStop)
                  {
                     if(!OrderModify(OrderTicket(), OrderOpenPrice(), newStop, 0, 0, clrNONE))
                        Print("Failed to modify stop. Error: ", GetLastError());
                  }
               }
            }
            else if(OrderType() == OP_SELL && (TradingMode == MODE_SHORT || TradingMode == MODE_MIXED))
            {
               double currentProfit = OrderOpenPrice() - MarketInfo(Symbol(), MODE_ASK);
               double currentStop = OrderStopLoss();
               
               if(currentProfit >= BreakevenTriggerPoints * point)
               {
                  double newStop = OrderOpenPrice() - (currentProfit - TrailingStopPoints * point);
                  
                  if(currentStop == 0 || newStop < currentStop)
                  {
                     if(!OrderModify(OrderTicket(), OrderOpenPrice(), newStop, 0, 0, clrNONE))
                        Print("Failed to modify stop. Error: ", GetLastError());
                  }
               }
            }
         }
      }
   }
}

void DeleteAllArrows()
{
    int total = ObjectsTotal();
    for(int i = total-1; i >= 0; i--)
    {
        string name = ObjectName(i);
        if(ObjectType(name) == OBJ_ARROW)
        {
            ObjectDelete(name);
        }
    }
}