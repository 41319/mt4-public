//+------------------------------------------------------------------+
//|                                                      HKIndex.mq4 |
//|                        Generated by MetaEditor                   |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Your Name"
#property link      "https://www.yourwebsite.com"
#property version   "1.10"
#property strict

// Input parameters
input double LotSize = 0.01;
input int TrailingStopPoints = 30 * 10;      // Only activates in profit
input int BreakevenTriggerPoints = 50 * 10;  // Profit level to activate stop
input int MaxOrders = 10;
input int MagicNumber = 12345;
input double PriceLevelAdjustment = 50 * 10;
input bool UsePercentage = false;
input int OrderExpirationHours = 24;         // Pending order expiration
input double GapThresholdPoints =  51 * 10; // Points above highest level to trigger recalculation

// Global variables
double priceLevels[];
datetime lastCheckDate = 0;
double monthlyVolume = 0;


//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{

   UpdatePriceLevels();
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("HKIndex EA deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   bool isNewDay = TimeDay(TimeCurrent()) != TimeDay(lastCheckDate);
   
   if(isNewDay)
   {

      lastCheckDate = TimeCurrent();
   }
   
   // Check if price has moved beyond our highest level + gap threshold
   if(CheckPriceGap() || isNewDay)
   {
      UpdatePriceLevels();
      CloseAllPendingOrders();

   }
   
   ManageOrders();
   CheckForTrailingStop();
   DeleteAllArrows();
   CheckAndModifyDeepOrders()
}

//+------------------------------------------------------------------+
//| Check if current price exceeds highest level by gap threshold    |
//+------------------------------------------------------------------+
bool CheckPriceGap()
{
   if(ArraySize(priceLevels) == 0) return false;
   
   double highestLevel = priceLevels[ArrayMaximum(priceLevels)];
   double currentPrice = MarketInfo(Symbol(), MODE_BID);
   double gapThreshold = GapThresholdPoints * MarketInfo(Symbol(), MODE_POINT);
   
   if(currentPrice > (highestLevel + gapThreshold))
   {
      Print("Price gap detected (", currentPrice, " > ", highestLevel, " + ", gapThreshold, "). Recalculating levels.");
      return true;
   }
   return false;
}


//+------------------------------------------------------------------+
//| Count existing orders with matching symbol and magic             |
//+------------------------------------------------------------------+
int CountOrders()
{
   int count = 0;
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            count++;
         }
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Place a pending Buy Limit order                                  |
//+------------------------------------------------------------------+
void PlaceOrder(int index)
{
   double point = MarketInfo(Symbol(), MODE_POINT);
   int digits = (int)MarketInfo(Symbol(), MODE_DIGITS);
   double triggerPrice = priceLevels[index];
   datetime expiryTime = TimeCurrent() + OrderExpirationHours * 3600;

   // Safety checks
   if(triggerPrice >= MarketInfo(Symbol(), MODE_ASK))
   {
      Print("Trigger price too high. Skipping. Trigger: ", triggerPrice, " >= Ask: ", MarketInfo(Symbol(), MODE_ASK));
      return;
   }

   Print("Attempting BUYLIMIT @ ", triggerPrice);
   int ticket = OrderSend(Symbol(), OP_BUYLIMIT, LotSize, triggerPrice, 3, 0, 0, "HKIndex EA", MagicNumber, expiryTime, clrGreen);

   if(ticket < 0)
      Print("OrderSend failed. Error: ", GetLastError());
   else
      Print("Order placed. Ticket #", ticket);
}

//+------------------------------------------------------------------+
//| Manage all orders - create new ones if needed                    |
//+------------------------------------------------------------------+
void ManageOrders()
{
   int count = CountOrders();
   
   for(int i = 0; i < MaxOrders; i++)
   {
      bool orderExists = false;
      for(int j = 0; j < OrdersTotal(); j++)
      {
         if(OrderSelect(j, SELECT_BY_POS, MODE_TRADES))
         {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber &&
               MathAbs(OrderOpenPrice() - priceLevels[i]) < MarketInfo(Symbol(), MODE_POINT))
            {
               orderExists = true;
               break;
            }
         }
      }

      if(!orderExists && count < MaxOrders)
      {
         PlaceOrder(i);
         count++;
      }
   }
}

//+------------------------------------------------------------------+
//| Update price levels based on current market price                |
//+------------------------------------------------------------------+
void UpdatePriceLevels()
{
   double currentPrice = MarketInfo(Symbol(), MODE_BID);
   ArrayResize(priceLevels, MaxOrders);
   
   for(int i = 0; i < MaxOrders; i++)
   {
      if(UsePercentage)
      {
         priceLevels[i] = currentPrice * (1 - (PriceLevelAdjustment / 100.0 * (i + 1)));
      }
      else
      {
         priceLevels[i] = NormalizeDouble(currentPrice - (PriceLevelAdjustment * (i + 1) * MarketInfo(Symbol(), MODE_POINT)), (int)MarketInfo(Symbol(), MODE_DIGITS));
      }
      Print("Price Level ", i+1, ": ", priceLevels[i]);
   }
}

//+------------------------------------------------------------------+
//| Close all pending orders                                         |
//+------------------------------------------------------------------+
void CloseAllPendingOrders()
{
   for(int i = OrdersTotal()-1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && OrderType() == OP_BUYLIMIT)
         {
            bool result = OrderDelete(OrderTicket());
            if(!result)
               Print("Failed to delete order. Error: ", GetLastError());
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Smart Trailing Stop - Only protects profits                      |
//+------------------------------------------------------------------+
void CheckForTrailingStop()
{
   double point = MarketInfo(Symbol(), MODE_POINT);
   
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && OrderType() == OP_BUY)
         {
            double currentProfit = MarketInfo(Symbol(), MODE_BID) - OrderOpenPrice();
            double currentStop = OrderStopLoss();
            
            // Check if we should activate stop protection
            if(currentProfit >= BreakevenTriggerPoints * point)
            {
               double newStop = OrderOpenPrice() + (currentProfit - TrailingStopPoints * point);
               
               // Only move stop if it's higher than current stop or no stop set
               if(currentStop == 0 || newStop > currentStop)
               {
                  if(!OrderModify(OrderTicket(), OrderOpenPrice(), newStop, 0, 0, clrNONE))
                     Print("Failed to modify stop. Error: ", GetLastError());
               }
            }
         }
      }
   }
}

void DeleteAllArrows()
{
    int total = ObjectsTotal();
    for(int i = total-1; i >= 0; i--)
    {
        string name = ObjectName(i);
        if (ObjectType(name) == OBJ_ARROW)
        {
            ObjectDelete(name);
        }
    }
}

//+------------------------------------------------------------------+
//| Check and modify orders based on price movement                  |
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
//| Check and modify orders based on price movement                  |
//+------------------------------------------------------------------+
void CheckAndModifyDeepOrders()
{
    bool hasVolumeOneOrder = false;
    double point = MarketInfo(Symbol(), MODE_POINT);
    int digits = (int)MarketInfo(Symbol(), MODE_DIGITS);
    
    // First pass: Check if any order already has volume of 1
    for(int i = 0; i < OrdersTotal(); i++)
    {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && OrderLots() == 1.0)
            {
                hasVolumeOneOrder = true;
                break;
            }
        }
    }
    
    // If no volume 1 orders found, look for deep orders to modify
    if(!hasVolumeOneOrder)
    {
        for(int i = 0; i < OrdersTotal(); i++)
        {
            if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
            {
                if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && OrderType() == OP_BUY)
                {
                    double currentPrice = MarketInfo(Symbol(), MODE_BID);
                    double openPrice = OrderOpenPrice();
                    double priceDifference = (openPrice - currentPrice) / point;
                    
                    // Check if price is 300 points below opening
                    if(priceDifference >= 300)
                    {
                        double newTakeProfit = NormalizeDouble(currentPrice + (20 * point), digits);
                        double currentStopLoss = OrderStopLoss();
                        
                        // Close the original order
                        if(OrderClose(OrderTicket(), OrderLots(), MarketInfo(Symbol(), MODE_BID), 3, clrNONE))
                        {
                            // Reopen with same parameters but volume 1 and new TP
                            int ticket = OrderSend(
                                Symbol(),                      // symbol
                                OP_BUY,                       // operation
                                1.0,                          // volume (changed to 1)
                                MarketInfo(Symbol(), MODE_ASK), // price
                                3,                            // slippage
                                currentStopLoss,              // stop loss (same as original)
                                newTakeProfit,                // take profit (20 points)
                                OrderComment(),               // same comment
                                MagicNumber,                  // same magic number
                                0,                            // expiration
                                OrderColor()                  // same color
                            );
                            
                            if(ticket < 0)
                            {
                                Print("Failed to reopen order with volume 1. Error: ", GetLastError());
                            }
                            else
                            {
                                Print("Order modified - Volume: 1, TP: ", newTakeProfit);
                            }
                        }
                        else
                        {
                            Print("Failed to close order for volume modification. Error: ", GetLastError());
                        }
                    }
                }
            }
        }
    }
}