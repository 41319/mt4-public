//+------------------------------------------------------------------+
//|                                                      HKIndex.mq4 |
//|                        Generated by MetaEditor                   |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Your Name"
#property link      "https://www.yourwebsite.com"
#property version   "1.10"
#property strict

// Input parameters
input double LotSize = 0.01;
input int TrailingStopPoints = 30 * 10;      // Only activates in profit
input int BreakevenTriggerPoints = 50 * 10;  // Profit level to activate stop
input int MaxBuyOrders = 10;                 // Max buy orders (market + pending)
input int MaxSellOrders = 10;                // Max sell orders (market + pending)
input int MagicNumber = 12345;
input int PriceLevelAdjustment = 25 * 10;    // Changed from double to int since we're only using points now
input int OrderExpirationHours = 24;         // Pending order expiration
input int GapThresholdPoints = 26 * 10;      // Points above/below highest/lowest level to trigger recalculation

// Global variables
double buyLevels[];
double sellLevels[];
datetime lastCheckDate = 0;
double monthlyVolume = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   UpdatePriceLevels();
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("HKIndex EA deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   bool isNewDay = TimeDay(TimeCurrent()) != TimeDay(lastCheckDate);
   
   if(isNewDay)
   {
      lastCheckDate = TimeCurrent();
   }
   
   // Check if price has moved beyond our levels + gap threshold
   int gapCheck = CheckPriceGap();
   if(gapCheck != 0 || isNewDay)
   {
      if(gapCheck == 1) // Need to update buy levels
      {
         UpdateBuyLevels();
         CloseAllPendingOrders(OP_BUYLIMIT);
      }
      else if(gapCheck == -1) // Need to update sell levels
      {
         UpdateSellLevels();
         CloseAllPendingOrders(OP_SELLLIMIT);
      }
      else if(isNewDay) // New day - update all
      {
         UpdatePriceLevels();
         CloseAllPendingOrders();
      }
   }
   
   ManageOrders();
   CheckForTrailingStop();
   DeleteAllArrows();
}

//+------------------------------------------------------------------+
//| Check if current price exceeds levels by gap threshold           |
//| Returns: 1=update buy levels, -1=update sell levels, 0=no update|
//+------------------------------------------------------------------+
int CheckPriceGap()
{
   if(ArraySize(buyLevels) == 0 || ArraySize(sellLevels) == 0) return 0;
   
   double highestBuyLevel = buyLevels[ArrayMaximum(buyLevels)];
   double lowestSellLevel = sellLevels[ArrayMinimum(sellLevels)];
   double currentPrice = MarketInfo(Symbol(), MODE_BID);
   double gapThreshold = GapThresholdPoints * MarketInfo(Symbol(), MODE_POINT);
   
   if(currentPrice > (lowestSellLevel + gapThreshold))
   {
      Print("Price moved above sell levels. Recalculating sell levels only.");
      return -1; // Need to update sell levels
   }
   else if(currentPrice < (highestBuyLevel - gapThreshold))
   {
      Print("Price moved below buy levels. Recalculating buy levels only.");
      return 1; // Need to update buy levels
   }
   return 0;
}

//+------------------------------------------------------------------+
//| Count existing orders with matching symbol and magic             |
//+------------------------------------------------------------------+
int CountOrders(int type = -1) // -1 = count all, OP_BUY/OP_SELL/OP_BUYLIMIT/OP_SELLLIMIT
{
   int count = 0;
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            if(type == -1 || OrderType() == type)
               count++;
         }
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Place a pending order                                            |
//+------------------------------------------------------------------+
void PlaceOrder(int index, int type)
{
   double point = MarketInfo(Symbol(), MODE_POINT);
   int digits = (int)MarketInfo(Symbol(), MODE_DIGITS);
   datetime expiryTime = TimeCurrent() + OrderExpirationHours * 3600;
   double triggerPrice = 0;
   color arrowColor = clrNONE;
   int orderType = 0;
   double currentAsk = MarketInfo(Symbol(), MODE_ASK);
   double currentBid = MarketInfo(Symbol(), MODE_BID);

   if(type == OP_BUYLIMIT)
   {
      triggerPrice = buyLevels[index];
      arrowColor = clrGreen;
      orderType = OP_BUYLIMIT;
      
      // Safety check
      if(triggerPrice >= currentAsk)
      {
         Print("Buy trigger price too high. Skipping. Trigger: ", triggerPrice, " >= Ask: ", currentAsk);
         return;
      }
   }
   else if(type == OP_SELLLIMIT)
   {
      triggerPrice = sellLevels[index];
      arrowColor = clrRed;
      orderType = OP_SELLLIMIT;
      
      // Safety check
      if(triggerPrice <= currentBid)
      {
         Print("Sell trigger price too low. Skipping. Trigger: ", triggerPrice, " <= Bid: ", currentBid);
         return;
      }
   }

   Print("Attempting ", OrderTypeToString(orderType), " @ ", triggerPrice);
   int ticket = OrderSend(Symbol(), orderType, LotSize, triggerPrice, 3, 0, 0, "HKIndex EA", MagicNumber, expiryTime, arrowColor);

   if(ticket < 0)
      Print("OrderSend failed. Error: ", GetLastError());
   else
      Print("Order placed. Ticket #", ticket);
}

string OrderTypeToString(int type)
{
   switch(type)
   {
      case OP_BUY: return "BUY";
      case OP_SELL: return "SELL";
      case OP_BUYLIMIT: return "BUYLIMIT";
      case OP_SELLLIMIT: return "SELLLIMIT";
      default: return "UNKNOWN";
   }
}

//+------------------------------------------------------------------+
//| Manage all orders - create new ones if needed                    |
//+------------------------------------------------------------------+
void ManageOrders()
{
   int buyCount = CountOrders(OP_BUY) + CountOrders(OP_BUYLIMIT);
   int sellCount = CountOrders(OP_SELL) + CountOrders(OP_SELLLIMIT);
   
   // Place buy orders
   for(int i = 0; i < MaxBuyOrders; i++)
   {
      bool orderExists = false;
      for(int j = 0; j < OrdersTotal(); j++)
      {
         if(OrderSelect(j, SELECT_BY_POS, MODE_TRADES))
         {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && 
               (OrderType() == OP_BUYLIMIT || OrderType() == OP_BUY) &&
               MathAbs(OrderOpenPrice() - buyLevels[i]) < MarketInfo(Symbol(), MODE_POINT))
            {
               orderExists = true;
               break;
            }
         }
      }

      if(!orderExists && buyCount < MaxBuyOrders)
      {
         PlaceOrder(i, OP_BUYLIMIT);
         buyCount++;
      }
   }
   
   // Place sell orders
   for(int i = 0; i < MaxSellOrders; i++)
   {
      bool orderExists = false;
      for(int j = 0; j < OrdersTotal(); j++)
      {
         if(OrderSelect(j, SELECT_BY_POS, MODE_TRADES))
         {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && 
               (OrderType() == OP_SELLLIMIT || OrderType() == OP_SELL) &&
               MathAbs(OrderOpenPrice() - sellLevels[i]) < MarketInfo(Symbol(), MODE_POINT))
            {
               orderExists = true;
               break;
            }
         }
      }

      if(!orderExists && sellCount < MaxSellOrders)
      {
         PlaceOrder(i, OP_SELLLIMIT);
         sellCount++;
      }
   }
}

//+------------------------------------------------------------------+
//| Update all price levels                                          |
//+------------------------------------------------------------------+
void UpdatePriceLevels()
{
   UpdateBuyLevels();
   UpdateSellLevels();
}

//+------------------------------------------------------------------+
//| Update buy price levels based on current market price            |
//+------------------------------------------------------------------+
void UpdateBuyLevels()
{
   double currentPrice = MarketInfo(Symbol(), MODE_BID);
   ArrayResize(buyLevels, MaxBuyOrders);
   
   for(int i = 0; i < MaxBuyOrders; i++)
   {
      buyLevels[i] = NormalizeDouble(currentPrice - (PriceLevelAdjustment * (i + 1) * MarketInfo(Symbol(), MODE_POINT)), (int)MarketInfo(Symbol(), MODE_DIGITS));
      Print("Updated Buy Level ", i+1, ": ", buyLevels[i]);
   }
}

//+------------------------------------------------------------------+
//| Update sell price levels based on current market price           |
//+------------------------------------------------------------------+
void UpdateSellLevels()
{
   double currentPrice = MarketInfo(Symbol(), MODE_BID);
   ArrayResize(sellLevels, MaxSellOrders);
   
   for(int i = 0; i < MaxSellOrders; i++)
   {
      sellLevels[i] = NormalizeDouble(currentPrice + (PriceLevelAdjustment * (i + 1) * MarketInfo(Symbol(), MODE_POINT)), (int)MarketInfo(Symbol(), MODE_DIGITS));
      Print("Updated Sell Level ", i+1, ": ", sellLevels[i]);
   }
}

//+------------------------------------------------------------------+
//| Close all pending orders of specified type                       |
//+------------------------------------------------------------------+
void CloseAllPendingOrders(int type = -1) // -1 = all pending orders
{
   for(int i = OrdersTotal()-1; i >= 0; i--)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            if((type == -1 && (OrderType() == OP_BUYLIMIT || OrderType() == OP_SELLLIMIT)) ||
               (type == OP_BUYLIMIT && OrderType() == OP_BUYLIMIT) ||
               (type == OP_SELLLIMIT && OrderType() == OP_SELLLIMIT))
            {
               bool result = OrderDelete(OrderTicket());
               if(!result)
                  Print("Failed to delete order. Error: ", GetLastError());
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Smart Trailing Stop - Only protects profits                      |
//+------------------------------------------------------------------+
void CheckForTrailingStop()
{
   double point = MarketInfo(Symbol(), MODE_POINT);
   
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
         {
            if(OrderType() == OP_BUY)
            {
               double currentProfit = MarketInfo(Symbol(), MODE_BID) - OrderOpenPrice();
               double currentStop = OrderStopLoss();
               
               // Check if we should activate stop protection
               if(currentProfit >= BreakevenTriggerPoints * point)
               {
                  double newStop = OrderOpenPrice() + (currentProfit - TrailingStopPoints * point);
                  
                  // Only move stop if it's higher than current stop or no stop set
                  if(currentStop == 0 || newStop > currentStop)
                  {
                     if(!OrderModify(OrderTicket(), OrderOpenPrice(), newStop, OrderTakeProfit(), 0, clrNONE))
                        Print("Failed to modify buy stop. Error: ", GetLastError());
                  }
               }
            }
            else if(OrderType() == OP_SELL)
            {
               double currentProfit = OrderOpenPrice() - MarketInfo(Symbol(), MODE_ASK);
               double currentStop = OrderStopLoss();
               
               // Check if we should activate stop protection
               if(currentProfit >= BreakevenTriggerPoints * point)
               {
                  double newStop = OrderOpenPrice() - (currentProfit - TrailingStopPoints * point);
                  
                  // Only move stop if it's lower than current stop or no stop set
                  if(currentStop == 0 || newStop < currentStop)
                  {
                     if(!OrderModify(OrderTicket(), OrderOpenPrice(), newStop, OrderTakeProfit(), 0, clrNONE))
                        Print("Failed to modify sell stop. Error: ", GetLastError());
                  }
               }
            }
         }
      }
   }
}

void DeleteAllArrows()
{
    int total = ObjectsTotal();
    for(int i = total-1; i >= 0; i--)
    {
        string name = ObjectName(i);
        if (ObjectType(name) == OBJ_ARROW)
        {
            ObjectDelete(name);
        }
    }
}