//+------------------------------------------------------------------+
//|                                                      HKIndex.mq4 |
//|                        Generated by MetaEditor                   |
//|                                              https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Your Name"
#property link      "https://www.yourwebsite.com"
#property version   "1.01"
#property strict

// Input parameters
input double LotSize = 0.01;
input int TakeProfitPoints = 50;
input int MaxOrders = 3;
input int MagicNumber = 12345;
input double PriceLevelAdjustment = 100;
input bool UsePercentage = false;

// Global variables
int ticket = -1;
double priceLevels[];
datetime lastCheckDate = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit() {


   return(INIT_SUCCEEDED);

}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
   Print("HKIndex EA deinitialized");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick() {

      bool isNewDay = TimeDay(TimeCurrent()) != TimeDay(lastCheckDate);
   RunDailyChecks(isNewDay);
   
}

//+------------------------------------------------------------------+
//| Count existing orders with matching symbol and magic             |
//+------------------------------------------------------------------+
int CountOrders() {
   int count = 0;
   for (int i = 0; i < OrdersTotal(); i++) {
      if (OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
         if (OrderSymbol() == Symbol()) {
            count++;
         }
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| Place a pending Buy Limit order                                  |
//+------------------------------------------------------------------+
void PlaceOrder(int index) {


   double point = MarketInfo(Symbol(), MODE_POINT);
   int digits = MarketInfo(Symbol(), MODE_DIGITS);
   double triggerPrice = priceLevels[index];
   double takeProfitPrice = priceLevels[index] + TakeProfitPoints; //50;// NormalizeDouble(triggerPrice + TakeProfitPoints * point, digits);
   datetime expiryTime = TimeCurrent() + 86400; // 24 hours later

   // Safety check: triggerPrice must be below current Ask for BuyLimit
   if (triggerPrice >= MarketInfo(Symbol(), MODE_ASK)) {
      Print("Trigger price is too high for BuyLimit. Skipping. Trigger: ", triggerPrice, " >= Ask: ", MarketInfo(Symbol(), MODE_ASK));
      return;
   }

   Print(Symbol(), " | Attempting BUYLIMIT | Price: ", triggerPrice, ", TP: ", takeProfitPrice);
   ticket = OrderSend(Symbol(), OP_BUYLIMIT, LotSize, triggerPrice, 3, 0, takeProfitPrice, "HKIndex EA", MagicNumber, expiryTime, clrGreen);

   if (ticket < 0) {
      int errorCode = GetLastError();
      Print("OrderSend failed with error #", errorCode);
   } else {
      Print("Order placed. Ticket #", ticket, " @ ", triggerPrice, ", TP @ ", takeProfitPrice);
   }
}

//+------------------------------------------------------------------+
//| Handle closed orders (currently unused)                          |
//+------------------------------------------------------------------+
void OnOrderClose(const int ticket, const int magic_number, const double lots, const datetime close_time, const double close_price) {
   if (magic_number == MagicNumber) {
      Print("Order closed. Ticket #", ticket, " @ ", close_price);
   }
}

//+------------------------------------------------------------------+
//| Run daily logic and recreate missing orders                      |
//+------------------------------------------------------------------+
void RunDailyChecks(bool isNewDay) {
   if (isNewDay) {
      double openingPrice = iOpen(Symbol(), PERIOD_D1, 0);
      Print("New day detected. Daily opening price: ", openingPrice);

      ArrayResize(priceLevels, MaxOrders);
      for (int i = 0; i < MaxOrders; i++) {
         if (UsePercentage) {
            priceLevels[i] = openingPrice * (1 - (PriceLevelAdjustment / 100.0) * (i + 1));
         } else {
            priceLevels[i] = openingPrice - (PriceLevelAdjustment * (i + 1));
         }
         
         Print(priceLevels[i]);
      }
      
      lastCheckDate = TimeCurrent();
   }

   int count = CountOrders();
   if (count > 0) {
      Print("Open orders/positions: ", count);
   }

   for (int i = 0; i < MaxOrders; i++) {
      bool orderExists = false;
      for (int j = 0; j < OrdersTotal(); j++) {
         if (OrderSelect(j, SELECT_BY_POS, MODE_TRADES)) {
            if (OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber &&
                MathAbs(OrderOpenPrice() - priceLevels[i]) < MarketInfo(Symbol(), MODE_POINT)) {
               orderExists = true;
               break;
            }
         }
      }

      if (!orderExists && count < MaxOrders) {
         PlaceOrder(i);
         count++;
      }
   }
}
